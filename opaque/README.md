# opaque

- 외부에서는 멤버에 접근할 수 없는 구조체를 정의하는 방식
- 라이브러리의 공개용 헤더 파일에 구조체를 선언만 하고 정의는 내부 코드에서 구현
  - 구조체의 생성과 수정은 모두 공개 API로만 진행할 수 있다.
  - 구조체와 인터페이스를 분리할 수 있다.

## 컴포넌트

- libextern.h
  - 라이브러리 공개용 헤더파일
- libexam.c
  - 라이브러리 소스 코드
- libexam.h
  - 내부에서 사용하는 헤더파일
- main.c
  - 애플리케이션 소스 코드

## 회고

- 각 소스 코드는 완전히 독립적임을 다시 한번 상기한다.
  - main.c에서 `struct user_st`를 포인터로 선언했다.
    - 포인터로 선언하여 구조체 내부 구현에 대한 관심은 미뤄둘 수 있다.
    - 포인터로 선언하지 않으면 
      - `struct user_st user = { 0 };`
      - `error: variable 'user' has initializer but incomplete type`
- main.c에서 접근하는 헤더파일(libextern.h)에는 `struct user_st`에 대한 선언만 존재한다.

- ✅ 함수와 구조체의 차이
  - 소스 코드에 함수에 대한 정의가 없어도 소스 코드는 컴파일이 된다.
    - 실행 과정에서 함수 이름으로 메모리에 올라온 함수 정의를 연결하면 되기 때문이다.
  - 하지만 구조체는 링킹하지 않기 때문에 해당 소스 코드에 구조체가 정의되어 있지 않으면 변수로 사용할 수 없다.
    - 컴파일 시점에서 구조체 크기를 컴파일러가 판단할 수 있어야한다.
    - 반면에 포인터로는 사용할 수 있다.
  - 결론
    - 컴파일러는 코드를 분석하며 정확한 메모리 크기와 레이아웃을 알아야한다.
      - 구조체 인스턴스가 스택에 올라올 때, 얼마나 할당해야 하는지 판단하기 위해서
      - 레이아웃이란, 구조체가 메모리에서 어떻게 배치되는지; 멤버는 어떤 순서이고 각 멤버는 어떤 오프셋에 저장되는지

## 실행

```
cmake -Bbuild
```
